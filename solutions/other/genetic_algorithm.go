package other

import (
	"fmt"
	"math/rand"
	"sort"
)

const (
	targetString   = "Hello, World!"
	populationSize = 100
	mutationRate   = 0.1
	maxGenerations = 1000
	tournamentSize = 5
	elitismCount   = 2
)

type Individual struct {
	genes   string
	fitness float64
}

func newIndividual(length int) Individual {
	genes := make([]byte, length)
	for i := range genes {
		genes[i] = byte(rand.Intn(95) + 32) // ASCII printable characters
	}
	return Individual{string(genes), 0}
}

func (ind *Individual) calculateFitness(target string) {
	score := 0
	for i := range ind.genes {
		if i < len(target) && ind.genes[i] == target[i] {
			score++
		}
	}
	ind.fitness = float64(score) / float64(len(target))
}

// Surprisingly good evolution algorithm example generated by Sonnet 3.5
func Run() {
	// Initialize population
	population := make([]Individual, populationSize)
	for i := range population {
		population[i] = newIndividual(len(targetString))
	}

	generation := 0
	bestFitness := 0.0

	for generation < maxGenerations && bestFitness < 1.0 {
		// Calculate fitness for all individuals
		for i := range population {
			population[i].calculateFitness(targetString)
		}

		// Sort population by fitness
		sort.Slice(population, func(i, j int) bool {
			return population[i].fitness > population[j].fitness
		})

		bestFitness = population[0].fitness

		fmt.Printf("Generation %d: Best = %s, Fitness = %.2f\n", generation, population[0].genes, bestFitness)

		// Create new generation
		population = evolve(population)
		generation++
	}
}

func evolve(population []Individual) []Individual {
	sort.Slice(population, func(i, j int) bool {
		return population[i].fitness > population[j].fitness
	})

	newPopulation := make([]Individual, populationSize)

	// Elitism
	copy(newPopulation[:elitismCount], population[:elitismCount])

	// Create rest of new population
	for i := elitismCount; i < populationSize; i++ {
		// Select two parents randomly and crossover them
		parent1 := tournamentSelection(population)
		parent2 := tournamentSelection(population)
		child := crossover(parent1, parent2)
		child = mutate(child)
		newPopulation[i] = child
	}

	return newPopulation
}

// Given population, select the fittest individual using random tournament selection.
func tournamentSelection(population []Individual) Individual {
	tournament := make([]Individual, tournamentSize)
	for i := range tournament {
		tournament[i] = population[rand.Intn(len(population))]
	}

	sort.Slice(tournament, func(i, j int) bool {
		return tournament[i].fitness > tournament[j].fitness
	})

	return tournament[0]
}

// Given two parents, create a new individual by crossover in random point.
// "aaaa" + "bbbb" at point 2 = "aabb"
func crossover(parent1, parent2 Individual) Individual {
	childGenes := make([]byte, len(parent1.genes))
	splitPoint := rand.Intn(len(parent1.genes))

	copy(childGenes[:splitPoint], parent1.genes[:splitPoint])
	copy(childGenes[splitPoint:], parent2.genes[splitPoint:])

	return Individual{string(childGenes), 0}
}

// Given an individual, make a small mutation (random character).
func mutate(ind Individual) Individual {
	genes := []byte(ind.genes)
	for i := range genes {
		if rand.Float64() < mutationRate {
			genes[i] = byte(rand.Intn(95) + 32)
		}
	}
	return Individual{string(genes), 0}
}
